// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: task.sql

package sqlc

import (
	"context"
)

const deleteTask = `-- name: DeleteTask :exec
delete from tasks
where id=?
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const fetchAllTasks = `-- name: FetchAllTasks :many
select t.id,u.name,t.user_id,t.content,t.state
from tasks as t inner join users as u
on t.user_id = u.id
`

type FetchAllTasksRow struct {
	ID      string
	Name    string
	UserID  string
	Content string
	State   int32
}

func (q *Queries) FetchAllTasks(ctx context.Context) ([]FetchAllTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllTasksRow{}
	for rows.Next() {
		var i FetchAllTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Content,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTaskById = `-- name: FetchTaskById :one
select t.id,u.name,t.user_id,t.content,t.state
from tasks as t inner join users as u
on t.user_id = u.id
where t.id = ?
`

type FetchTaskByIdRow struct {
	ID      string
	Name    string
	UserID  string
	Content string
	State   int32
}

func (q *Queries) FetchTaskById(ctx context.Context, id string) (FetchTaskByIdRow, error) {
	row := q.db.QueryRowContext(ctx, fetchTaskById, id)
	var i FetchTaskByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Content,
		&i.State,
	)
	return i, err
}

const fetchUserTasks = `-- name: FetchUserTasks :many
select t.id,u.name,t.user_id,t.content,t.state
from tasks as t inner join users as u
on t.user_id = u.id
where t.user_id = ?
`

type FetchUserTasksRow struct {
	ID      string
	Name    string
	UserID  string
	Content string
	State   int32
}

func (q *Queries) FetchUserTasks(ctx context.Context, userID string) ([]FetchUserTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchUserTasksRow{}
	for rows.Next() {
		var i FetchUserTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Content,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTaskById = `-- name: FindTaskById :one
select id,user_id,content,state
from tasks
where id = ?
`

type FindTaskByIdRow struct {
	ID      string
	UserID  string
	Content string
	State   int32
}

func (q *Queries) FindTaskById(ctx context.Context, id string) (FindTaskByIdRow, error) {
	row := q.db.QueryRowContext(ctx, findTaskById, id)
	var i FindTaskByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.State,
	)
	return i, err
}

const insertTask = `-- name: InsertTask :exec
insert into tasks(
    id,
    user_id,
    content,
    state
)values(
    ?,
    ?,
    ?,
    ?
)
`

type InsertTaskParams struct {
	ID      string
	UserID  string
	Content string
	State   int32
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) error {
	_, err := q.db.ExecContext(ctx, insertTask,
		arg.ID,
		arg.UserID,
		arg.Content,
		arg.State,
	)
	return err
}

const updateTask = `-- name: UpdateTask :exec
update tasks
set state=?
where id = ?
`

type UpdateTaskParams struct {
	State int32
	ID    string
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask, arg.State, arg.ID)
	return err
}
